<?php

namespace App\Services;

use App\Models\Asset;
use App\Models\Tenant;
use App\Services\AI\Contracts\AIProviderInterface;
use App\Services\MetadataVisibilityResolver;
use App\Services\TenantBucketService;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

/**
 * AI Metadata Generation Service
 *
 * Generates AI metadata candidates for assets by analyzing images using AI provider abstraction.
 * Creates candidates in asset_metadata_candidates table with producer='ai'.
 *
 * Critical Principles:
 * - Only processes fields with ai_eligible = true
 * - Only processes fields enabled for asset's category
 * - Only processes select/multiselect fields with options
 * - Creates candidates (not suggestions) - suggestions are generated by AiMetadataSuggestionJob
 * - Never blocks uploads on failure
 * - Tracks costs accurately
 * - Provider-agnostic: Uses AIProviderInterface, not specific providers
 */
class AiMetadataGenerationService
{
    protected AIProviderInterface $provider;
    protected string $defaultModel;
    protected MetadataVisibilityResolver $visibilityResolver;
    protected TenantBucketService $bucketService;

    /**
     * Create a new service instance.
     *
     * @param AIProviderInterface|null $provider Provider instance (resolved from container if not provided)
     * @param MetadataVisibilityResolver|null $visibilityResolver Visibility resolver (resolved from container if not provided)
     * @param TenantBucketService|null $bucketService Bucket service for S3 fetch (resolved from container if not provided)
     */
    public function __construct(?AIProviderInterface $provider = null, ?MetadataVisibilityResolver $visibilityResolver = null, ?TenantBucketService $bucketService = null)
    {
        $this->provider = $provider ?? app(AIProviderInterface::class);
        $this->visibilityResolver = $visibilityResolver ?? app(MetadataVisibilityResolver::class);
        $this->bucketService = $bucketService ?? app(TenantBucketService::class);

        $modelConfig = config('ai.models.gpt-4o-mini', []);
        $this->defaultModel = $modelConfig['model_name'] ?? 'gpt-4o-mini';
    }

    /**
     * Generate AI metadata candidates for an asset.
     *
     * @param Asset $asset
     * @return array Results: ['candidates_created' => int, 'cost' => float, 'fields_processed' => array, 'tokens_in' => int, 'tokens_out' => int]
     * @throws \Exception If API call fails (caller should handle gracefully)
     */
    public function generateMetadata(Asset $asset): array
    {
        // Get eligible fields
        $fields = $this->getEligibleFields($asset);
        
        if (empty($fields)) {
            Log::info('[AiMetadataGenerationService] No eligible fields', [
                'asset_id' => $asset->id,
            ]);
            return [
                'candidates_created' => 0,
                'cost' => 0.0,
                'fields_processed' => [],
                'tokens_in' => 0,
                'tokens_out' => 0,
            ];
        }

        // Build prompt
        $prompt = $this->buildPrompt($asset, $fields);

        // Fetch image bytes internally via S3/IAM (never pass presigned URLs to AI providers)
        $imageBase64DataUrl = $this->fetchThumbnailAsBase64DataUrl($asset);
        if (!$imageBase64DataUrl) {
            Log::error('[AiMetadataGenerationService] AI image fetch failed before provider call', [
                'asset_id' => $asset->id,
                'thumbnail_status' => $asset->thumbnail_status?->value ?? 'null',
            ]);
            throw new \Exception('AI image fetch failed before provider call');
        }

        // Call provider's image analysis method (passes base64 data URL, not S3 URL)
        $response = $this->provider->analyzeImage($imageBase64DataUrl, $prompt, [
            'model' => $this->defaultModel,
            'max_tokens' => 1000,
            'response_format' => ['type' => 'json_object'],
        ]);

        // Parse response (returns both candidates and tags from ONE Vision API call)
        $parsed = $this->parseResponse($response, $asset, $fields);
        $candidates = $parsed['candidates'] ?? [];
        $tags = $parsed['tags'] ?? [];
        
        // Create candidates in database
        $candidatesCreated = $this->createCandidates($asset, $candidates);
        
        // Create tags in database
        $tagsCreated = $this->createTags($asset, $tags);

        // Calculate cost using provider's cost calculation
        $cost = $this->provider->calculateCost(
            $response['tokens_in'] ?? 0,
            $response['tokens_out'] ?? 0,
            $response['model'] ?? $this->defaultModel
        );

        Log::info('[AiMetadataGenerationService] Generated metadata and tags', [
            'asset_id' => $asset->id,
            'candidates_created' => $candidatesCreated,
            'tags_created' => $tagsCreated,
            'fields_processed' => array_keys($candidates),
            'cost' => $cost,
            'tokens_in' => $response['tokens_in'] ?? 0,
            'tokens_out' => $response['tokens_out'] ?? 0,
        ]);

        return [
            'candidates_created' => $candidatesCreated,
            'tags_created' => $tagsCreated,
            'cost' => $cost,
            'fields_processed' => array_keys($candidates),
            'tokens_in' => $response['tokens_in'] ?? 0,
            'tokens_out' => $response['tokens_out'] ?? 0,
            'model' => $response['model'] ?? $this->defaultModel,
        ];
    }

    /**
     * Build AI inference plan for an asset (read-only planning step).
     *
     * Determines which metadata fields need AI inference using deterministic DB logic.
     * This is a read-only planning step that does NOT call AI or write metadata.
     *
     * @param Asset $asset
     * @return array Plan structure: ['fields' => [['key' => string, 'label' => string, 'type' => string, 'allowed_values' => array]]]
     */
    public function buildAiInferencePlan(Asset $asset): array
    {
        // Get category
        $categoryId = $asset->metadata['category_id'] ?? null;
        if (!$categoryId) {
            return ['fields' => []];
        }

        // Get ai_eligible fields that are select/multiselect
        $fields = DB::table('metadata_fields')
            ->where('ai_eligible', true)
            ->whereIn('type', ['select', 'multiselect'])
            ->where(function ($query) use ($asset) {
                $query->where('scope', 'system')
                    ->orWhere(function ($q) use ($asset) {
                        $q->where('tenant_id', $asset->tenant_id)
                            ->where('scope', '!=', 'system');
                    });
            })
            ->get();

        $planFields = [];
        foreach ($fields as $field) {
            // Check if field is enabled for category
            if (!$this->isFieldEnabledForCategory($asset, $field->id, $categoryId)) {
                continue;
            }

            // Check if field already has an approved value
            // If approved_at is not null, the field has an approved value and should be skipped
            $hasApprovedValue = DB::table('asset_metadata')
                ->where('asset_id', $asset->id)
                ->where('metadata_field_id', $field->id)
                ->whereNotNull('approved_at')
                ->exists();

            if ($hasApprovedValue) {
                continue;
            }

            // Get allowed_values (options)
            $allowedValues = DB::table('metadata_options')
                ->where('metadata_field_id', $field->id)
                ->pluck('value')
                ->toArray();

            if (empty($allowedValues)) {
                continue;
            }

            $planFields[] = [
                'key' => $field->key,
                'label' => $field->system_label ?? $field->key,
                'type' => $field->type,
                'allowed_values' => $allowedValues,
            ];
        }

        return [
            'fields' => $planFields,
        ];
    }

    /**
     * Get ai_eligible fields for asset's category.
     *
     * @param Asset $asset
     * @return array Array of field definitions with options
     */
    protected function getEligibleFields(Asset $asset): array
    {
        // Get category
        $categoryId = $asset->metadata['category_id'] ?? null;
        if (!$categoryId) {
            return [];
        }

        // Get ai_eligible fields
        $fields = DB::table('metadata_fields')
            ->where('ai_eligible', true)
            ->whereIn('type', ['select', 'multiselect'])
            ->where(function ($query) use ($asset) {
                $query->where('scope', 'system')
                    ->orWhere(function ($q) use ($asset) {
                        $q->where('tenant_id', $asset->tenant_id)
                            ->where('scope', '!=', 'system');
                    });
            })
            ->get();

        $enabledFields = [];
        foreach ($fields as $field) {
            // Check if field is enabled for category
            if (!$this->isFieldEnabledForCategory($asset, $field->id, $categoryId)) {
                continue;
            }

            // Check if field already has an approved value
            // If approved_at is not null, the field has an approved value and should be skipped
            // This prevents unnecessary API calls for fields that already have values
            $hasApprovedValue = DB::table('asset_metadata')
                ->where('asset_id', $asset->id)
                ->where('metadata_field_id', $field->id)
                ->whereNotNull('approved_at')
                ->exists();

            if ($hasApprovedValue) {
                continue;
            }

            // Get options
            $options = DB::table('metadata_options')
                ->where('metadata_field_id', $field->id)
                ->pluck('value', 'system_label')
                ->toArray();

            if (empty($options)) {
                continue;
            }

            $enabledFields[] = [
                'key' => $field->key,
                'label' => $field->system_label ?? $field->key,
                'type' => $field->type,
                'options' => array_values($options),
                'description' => $field->description ?? null,
            ];
        }

        return $enabledFields;
    }

    /**
     * Check if field is enabled for category.
     *
     * CRITICAL: Uses MetadataVisibilityResolver to check tenant/brand/category-specific visibility.
     * This ensures AI suggestions respect category-specific field enablement settings.
     *
     * @param Asset $asset
     * @param int $fieldId
     * @param int $categoryId
     * @return bool
     */
    protected function isFieldEnabledForCategory(Asset $asset, int $fieldId, int $categoryId): bool
    {
        $field = DB::table('metadata_fields')->where('id', $fieldId)->first();
        if (!$field) {
            return false;
        }

        // Get the category
        $category = \App\Models\Category::find($categoryId);
        if (!$category) {
            // Category doesn't exist - field is enabled by default
            return true;
        }

        // Get tenant for visibility check
        $tenant = \App\Models\Tenant::find($asset->tenant_id);
        if (!$tenant) {
            // Tenant doesn't exist - field is enabled by default
            return true;
        }

        // Use MetadataVisibilityResolver to check if field is visible for this category
        // This checks both system-level and tenant-level visibility overrides
        $fieldDefinition = [
            'field_id' => $fieldId,
            'key' => $field->key,
        ];

        return $this->visibilityResolver->isFieldVisible($fieldDefinition, $category, $tenant);
    }

    /**
     * Fetch medium thumbnail from S3/MinIO and return as base64 data URL.
     * Uses IAM role (worker) or configured credentials; never exposes S3 URLs to AI providers.
     *
     * @return string|null Base64 data URL (data:image/webp;base64,...) or null on failure
     */
    protected function fetchThumbnailAsBase64DataUrl(Asset $asset): ?string
    {
        $thumbnailPath = $this->resolveThumbnailPath($asset);
        if (!$thumbnailPath) {
            return null;
        }

        $bucket = $asset->storageBucket;
        if (!$bucket) {
            Log::warning('[AiMetadataGenerationService] Asset missing storage bucket', [
                'asset_id' => $asset->id,
            ]);
            return null;
        }

        try {
            $contents = $this->bucketService->getObjectContents($bucket, $thumbnailPath);
        } catch (\Throwable $e) {
            Log::error('[AiMetadataGenerationService] AI image fetch failed before provider call', [
                'asset_id' => $asset->id,
                'thumbnail_path' => $thumbnailPath,
                'bucket' => $bucket->name,
                'error' => $e->getMessage(),
            ]);
            return null;
        }

        if (strlen($contents) === 0) {
            Log::error('[AiMetadataGenerationService] AI image fetch failed: empty file', [
                'asset_id' => $asset->id,
                'thumbnail_path' => $thumbnailPath,
            ]);
            return null;
        }

        $base64 = base64_encode($contents);
        $mimeType = $this->inferMimeTypeFromPath($thumbnailPath);

        return "data:{$mimeType};base64,{$base64}";
    }

    /**
     * Resolve thumbnail path from asset metadata (same logic as Asset::getMediumThumbnailUrlAttribute).
     *
     * @return string|null S3 key path (assets/... or temp/uploads/...) or null if not available
     */
    protected function resolveThumbnailPath(Asset $asset): ?string
    {
        $metadata = $asset->metadata ?? [];

        if (isset($metadata['thumbnails']['medium']['path'])) {
            $path = $metadata['thumbnails']['medium']['path'];
            if (str_starts_with($path, 'assets/') || str_starts_with($path, 'temp/uploads/')) {
                if (str_starts_with($path, 'temp/uploads/') && $asset->thumbnail_status !== \App\Enums\ThumbnailStatus::COMPLETED) {
                    return null;
                }
                return $path;
            }
        }

        if (isset($metadata['preview_thumbnails']['preview']['path'])) {
            return $metadata['preview_thumbnails']['preview']['path'];
        }

        return null;
    }

    /**
     * Infer MIME type from file extension.
     */
    protected function inferMimeTypeFromPath(string $path): string
    {
        $ext = strtolower(pathinfo($path, PATHINFO_EXTENSION));
        $map = [
            'webp' => 'image/webp',
            'jpg' => 'image/jpeg',
            'jpeg' => 'image/jpeg',
            'png' => 'image/png',
            'gif' => 'image/gif',
        ];

        return $map[$ext] ?? 'image/webp';
    }

    /**
     * Build structured prompt for AI provider.
     *
     * Uses ONE Vision API call to infer both structured field values and general descriptive tags.
     *
     * @param Asset $asset
     * @param array $fields Field definitions
     * @return string Prompt text
     */
    protected function buildPrompt(Asset $asset, array $fields): string
    {
        $fieldsJson = [];
        foreach ($fields as $field) {
            $fieldsJson[$field['key']] = [
                'label' => $field['label'],
                'type' => $field['type'],
                'allowed_values' => $field['options'],
                'description' => $field['description'] ?? "The {$field['label']} for this image",
            ];
        }

        $prompt = "Analyze this image and provide both structured metadata field values and general descriptive tags.\n\n";
        
        $prompt .= "STRUCTURED FIELDS:\n";
        $prompt .= "For each field below, select ONLY from the provided allowed values.\n";
        $prompt .= "Fields to analyze:\n";
        $prompt .= json_encode($fieldsJson, JSON_PRETTY_PRINT) . "\n\n";
        
        $prompt .= "GENERAL TAGS:\n";
        $prompt .= "Also provide descriptive tags that capture the content, style, mood, or subject matter of the image.\n";
        $prompt .= "Tags should be: lowercase, singular form, no punctuation, descriptive keywords.\n\n";
        
        $prompt .= "REQUIREMENTS:\n";
        $prompt .= "- Only return fields/tags where you have high confidence (>= 0.90)\n";
        $prompt .= "- Include confidence score for each value/tag\n";
        $prompt .= "- If confidence is below 0.90, omit that field/tag\n";
        $prompt .= "- Field values must exactly match one of the allowed_values\n";
        $prompt .= "- Tags must be lowercase, singular, no punctuation\n";
        $prompt .= "- Return JSON format with both 'fields' and 'tags' sections:\n";
        $prompt .= "{\n";
        $prompt .= "  \"fields\": {\n";
        $prompt .= "    \"photo_type\": {\"value\": \"studio\", \"confidence\": 0.94}\n";
        $prompt .= "  },\n";
        $prompt .= "  \"tags\": [\n";
        $prompt .= "    {\"value\": \"beer\", \"confidence\": 0.91},\n";
        $prompt .= "    {\"value\": \"dramatic\", \"confidence\": 0.88}\n";
        $prompt .= "  ]\n";
        $prompt .= "}\n\n";
        $prompt .= "Response:";

        return $prompt;
    }


    /**
     * Parse AI provider response into candidates and tags.
     *
     * Handles unified response with both 'fields' and 'tags' sections from ONE Vision API call.
     *
     * @param array $response Provider response (from AIProviderInterface::analyzeImage)
     * @param Asset $asset
     * @param array $fields Field definitions
     * @return array ['candidates' => array, 'tags' => array] Candidates and tags ready for database insertion
     */
    protected function parseResponse(array $response, Asset $asset, array $fields): array
    {
        $text = $response['text'] ?? '';
        $candidates = [];
        $tags = [];

        try {
            $data = json_decode($text, true);
            if (!is_array($data)) {
                Log::warning('[AiMetadataGenerationService] Invalid JSON response', [
                    'asset_id' => $asset->id,
                    'response' => $text,
                ]);
                return ['candidates' => [], 'tags' => []];
            }

            // Parse structured fields
            $fieldsData = $data['fields'] ?? [];
            if (is_array($fieldsData)) {
                foreach ($fieldsData as $fieldKey => $fieldData) {
                    if (!is_array($fieldData)) {
                        continue;
                    }

                    $value = $fieldData['value'] ?? null;
                    $confidence = $fieldData['confidence'] ?? null;

                    // Validate confidence (must be >= 0.90)
                    if (!is_numeric($confidence) || (float) $confidence < 0.90) {
                        Log::debug('[AiMetadataGenerationService] Low confidence field skipped', [
                            'asset_id' => $asset->id,
                            'field_key' => $fieldKey,
                            'confidence' => $confidence,
                        ]);
                        continue;
                    }

                    // Find field definition
                    $field = null;
                    foreach ($fields as $f) {
                        if ($f['key'] === $fieldKey) {
                            $field = $f;
                            break;
                        }
                    }

                    if (!$field) {
                        continue;
                    }

                    // Validate value is in allowed options
                    if (!$this->isValueAllowed($value, $field)) {
                        Log::debug('[AiMetadataGenerationService] Invalid value skipped', [
                            'asset_id' => $asset->id,
                            'field_key' => $fieldKey,
                            'value' => $value,
                        ]);
                        continue;
                    }

                    $candidates[$fieldKey] = [
                        'value' => $value,
                        'confidence' => (float) $confidence,
                    ];
                }
            }

            // Parse general tags
            $tagsData = $data['tags'] ?? [];
            if (is_array($tagsData)) {
                foreach ($tagsData as $tagData) {
                    if (!is_array($tagData)) {
                        // Handle case where tags might be simple strings
                        if (is_string($tagData)) {
                            $tagData = ['value' => $tagData, 'confidence' => 0.90];
                        } else {
                            continue;
                        }
                    }

                    $tagValue = $tagData['value'] ?? null;
                    $confidence = $tagData['confidence'] ?? null;

                    if (empty($tagValue) || !is_string($tagValue)) {
                        continue;
                    }

                    // Validate confidence (must be >= 0.90)
                    if (!is_numeric($confidence) || (float) $confidence < 0.90) {
                        Log::debug('[AiMetadataGenerationService] Low confidence tag skipped', [
                            'asset_id' => $asset->id,
                            'tag' => $tagValue,
                            'confidence' => $confidence,
                        ]);
                        continue;
                    }

                    // Normalize tag: lowercase, singular, no punctuation
                    $normalizedTag = $this->normalizeTag($tagValue);
                    if (empty($normalizedTag)) {
                        continue;
                    }

                    $tags[] = [
                        'value' => $normalizedTag,
                        'confidence' => (float) $confidence,
                    ];
                }
            }
        } catch (\Exception $e) {
            Log::error('[AiMetadataGenerationService] Failed to parse response', [
                'asset_id' => $asset->id,
                'error' => $e->getMessage(),
                'response' => $text,
            ]);
        }

        return [
            'candidates' => $candidates,
            'tags' => $tags,
        ];
    }

    /**
     * Normalize tag: lowercase, singular, no punctuation.
     *
     * @param string $tag
     * @return string Normalized tag
     */
    protected function normalizeTag(string $tag): string
    {
        // Convert to lowercase
        $tag = strtolower(trim($tag));
        
        // Remove punctuation (keep alphanumeric and spaces)
        $tag = preg_replace('/[^a-z0-9\s]/', '', $tag);
        
        // Convert to singular (basic plural removal - could be enhanced)
        // Remove trailing 's' if word is plural (simple heuristic)
        if (strlen($tag) > 1 && substr($tag, -1) === 's' && substr($tag, -2, 1) !== 's') {
            $tag = substr($tag, 0, -1);
        }
        
        // Remove extra spaces and trim
        $tag = preg_replace('/\s+/', ' ', $tag);
        $tag = trim($tag);
        
        return $tag;
    }

    /**
     * Check if value is allowed (in field options).
     *
     * @param mixed $value
     * @param array $field Field definition
     * @return bool
     */
    protected function isValueAllowed($value, array $field): bool
    {
        $options = $field['options'] ?? [];
        
        if ($field['type'] === 'multiselect') {
            if (!is_array($value)) {
                return false;
            }
            // All values must be in options
            foreach ($value as $v) {
                if (!in_array($v, $options, true)) {
                    return false;
                }
            }
            return true;
        }

        // Single select
        return in_array($value, $options, true);
    }

    /**
     * Create metadata field candidates in asset_metadata_candidates table.
     *
     * Stores AI-generated field values as candidates (not approved data).
     * Candidates must be reviewed and approved before being applied to the asset.
     *
     * @param Asset $asset
     * @param array $candidates Array of field candidates: ['field_key' => ['value' => mixed, 'confidence' => float]]
     * @return int Number of candidates created
     */
    protected function createCandidates(Asset $asset, array $candidates): int
    {
        if (empty($candidates)) {
            return 0;
        }

        $created = 0;
        foreach ($candidates as $fieldKey => $candidateData) {
            // Get field ID
            $field = DB::table('metadata_fields')
                ->where('key', $fieldKey)
                ->where(function ($query) use ($asset) {
                    $query->where('scope', 'system')
                        ->orWhere(function ($q) use ($asset) {
                            $q->where('tenant_id', $asset->tenant_id)
                                ->where('scope', '!=', 'system');
                        });
                })
                ->first();

            if (!$field) {
                continue;
            }

            // Check if candidate already exists
            $existing = DB::table('asset_metadata_candidates')
                ->where('asset_id', $asset->id)
                ->where('metadata_field_id', $field->id)
                ->where('producer', 'ai')
                ->whereNull('resolved_at')
                ->whereNull('dismissed_at')
                ->first();

            if ($existing) {
                // Update existing candidate
                DB::table('asset_metadata_candidates')
                    ->where('id', $existing->id)
                    ->update([
                        'value_json' => json_encode($candidateData['value']),
                        'confidence' => $candidateData['confidence'],
                        'source' => 'ai',
                        'updated_at' => now(),
                    ]);
            } else {
                // Create new candidate
                DB::table('asset_metadata_candidates')->insert([
                    'asset_id' => $asset->id,
                    'metadata_field_id' => $field->id,
                    'value_json' => json_encode($candidateData['value']),
                    'confidence' => $candidateData['confidence'],
                    'source' => 'ai',
                    'producer' => 'ai',
                    'created_at' => now(),
                    'updated_at' => now(),
                ]);
            }

            $created++;
        }

        return $created;
    }

    /**
     * Create tag candidates in asset_tag_candidates table.
     *
     * Stores AI-generated tags as candidates (not approved data).
     * Tags must be reviewed and approved before being applied to the asset.
     *
     * @param Asset $asset
     * @param array $tags Array of ['value' => string, 'confidence' => float]
     * @return int Number of tag candidates created
     */
    protected function createTags(Asset $asset, array $tags): int
    {
        if (empty($tags)) {
            return 0;
        }

        $created = 0;
        $now = now();

        foreach ($tags as $tagData) {
            $tagValue = $tagData['value'] ?? null;
            $confidence = $tagData['confidence'] ?? null;

            if (empty($tagValue) || !is_string($tagValue)) {
                continue;
            }

            // Phase J.2.1: Normalize tag and check if canonical form has been dismissed
            $tagNormalizationService = app(\App\Services\TagNormalizationService::class);
            $tenant = Tenant::find($asset->tenant_id);
            $canonicalTag = $tagNormalizationService->normalize($tagValue, $tenant);

            // Skip if normalization results in blocked/invalid tag
            if ($canonicalTag === null) {
                continue;
            }

            // Check if any candidate with this canonical form has been dismissed
            $allCandidates = DB::table('asset_tag_candidates')
                ->where('asset_id', $asset->id)
                ->where('producer', 'ai')
                ->whereNotNull('dismissed_at')
                ->get();

            $canonicalDismissed = false;
            foreach ($allCandidates as $dismissedCandidate) {
                $dismissedCanonical = $tagNormalizationService->normalize($dismissedCandidate->tag, $tenant);
                if ($dismissedCanonical === $canonicalTag) {
                    $canonicalDismissed = true;
                    break;
                }
            }

            if ($canonicalDismissed) {
                // Skip creating candidate for dismissed canonical tag
                continue;
            }

            // Check if candidate already exists (avoid duplicates)
            $existing = DB::table('asset_tag_candidates')
                ->where('asset_id', $asset->id)
                ->where('tag', $tagValue)
                ->where('producer', 'ai')
                ->whereNull('resolved_at')
                ->whereNull('dismissed_at')
                ->first();

            if ($existing) {
                // Update existing candidate with new confidence if higher
                if (is_numeric($confidence) && $confidence > ($existing->confidence ?? 0)) {
                    DB::table('asset_tag_candidates')
                        ->where('id', $existing->id)
                        ->update([
                            'confidence' => $confidence,
                            'updated_at' => $now,
                        ]);
                    $created++;
                }
                continue;
            }

            // Create new tag candidate (NOT approved - stored as candidate for review)
            DB::table('asset_tag_candidates')->insert([
                'asset_id' => $asset->id,
                'tag' => $tagValue,
                'source' => 'ai',
                'confidence' => is_numeric($confidence) ? $confidence : null,
                'producer' => 'ai',
                'created_at' => $now,
                'updated_at' => $now,
            ]);

            $created++;
        }

        return $created;
    }

}
